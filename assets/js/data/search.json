[ { "title": "How I customized Chirpy(1) - utterances 테마", "url": "/posts/how-i-customized-chirpy-1/", "categories": "Etc", "tags": "jekyll, chirpy", "date": "2022-02-12 20:47:00 +0900", "snippet": " Deprecated최신 버전을 사용하면 이 작업은 필요 없습니다.블로그 테마 변경과 연동되는 utterances이 블로그는 댓글 컴포넌트로 utterances를 사용하고 있습니다.그런데 chirpy는 블로그 왼쪽 메뉴에 있는 버튼이나, 시스템 설정의 변경으로 다크/라이트 테마로 변경이 가능한데, utterances의 테마가 자동으로 그에 따라 바뀌...", "content": " Deprecated최신 버전을 사용하면 이 작업은 필요 없습니다.블로그 테마 변경과 연동되는 utterances이 블로그는 댓글 컴포넌트로 utterances를 사용하고 있습니다.그런데 chirpy는 블로그 왼쪽 메뉴에 있는 버튼이나, 시스템 설정의 변경으로 다크/라이트 테마로 변경이 가능한데, utterances의 테마가 자동으로 그에 따라 바뀌진 않는데요!당연히 테마 변경 시 부자연스러우니 댓글 창의 테마도 따라 바뀌었으면 해서 작업 한 내용을 작성하고자 합니다.수정 / 추가한 파일_includes/posts.html를 변경하긴 했지만 해당 수정 내용은 그저 함수를 추가하고, 테마 변경 시 그 함수를 끼워넣은 것이기 때문에 댓글 창과 같은 페이지에 있을 수 있는 곳에 추가해도 됩니다. (다른 파일로 만들고 포함시켜도 됨)mode-toggle.html위 파일에 테마 변경에 대한 것이 클래스로 정의되어 있어요.봐야할 건 두 가지 함수입니다.this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid();});여기서는 시스템 설정이 변경된 걸 감지하고 테마를 바꿔주는 부분이에요.flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid();}여기가 변경 버튼 클릭 시 이벤트를 정의해 놓은 곳입니다.얘네 둘에 내가 원하는 동작을 끼워넣어주면 되겠죠?!posts.html{% if site.comments.provider == 'disqus' %} {% if site.disqus.comments and page.comments %} {% include disqus.html %} {% endif %}{% elsif site.comments.provider == 'utterances' %} {% assign utterances = site.utterances %} &lt;script src=\"https://utteranc.es/client.js\" repo= {{ utterances.repo }} issue-term= {{ utterances.issue-term }} theme= {{ utterances.theme }} crossorigin= \"anonymous\" async&gt; &lt;/script&gt; &lt;script&gt; function updateUtterancesTheme() { const message = { type: 'set-theme', theme: 'github-' + toggle.modeStatus }; const utterances = document.querySelector('.utterances-frame').contentWindow; utterances.postMessage(message, 'https://utteranc.es'); }; addEventListener('message', event =&gt; { if (event.origin !== 'https://utteranc.es') { return; } updateUtterancesTheme(); }); toggle.originFlipMode = toggle.flipMode; toggle.flipMode = function() { this.originFlipMode(); updateUtterancesTheme(); }; toggle.sysDarkPrefers.addListener(updateUtterancesTheme) &lt;/script&gt;{% endif %}updateUtterancesTheme 메서드부터~~utterances 렌더링되는 위치에 같이 때려박았습니다.끗" }, { "title": "How I customized Hydejack(5) - Top Navigation", "url": "/posts/how-i-customized-hydejack-5-topmenu/", "categories": "Etc", "tags": "hydejack, jekyll", "date": "2021-01-05 22:40:00 +0900", "snippet": "사이드 바의 메뉴들과 같이 _config.yml에 카테고리를 추가하면 자동으로 추가됩니다.사이드바가 들어갔을 때 다시 펼쳐서 메뉴 누르기가 불편하다고 생각되서 상단 네비게이션 바도 추가하게 되었습니다.뭔가 잡다해지는거 같기도 한데..어차피 글 볼땐 숨겨질테니! 아무튼 불편해서 추가했습니다! 수정/추가한 파일 menu.html ...", "content": "사이드 바의 메뉴들과 같이 _config.yml에 카테고리를 추가하면 자동으로 추가됩니다.사이드바가 들어갔을 때 다시 펼쳐서 메뉴 누르기가 불편하다고 생각되서 상단 네비게이션 바도 추가하게 되었습니다.뭔가 잡다해지는거 같기도 한데..어차피 글 볼땐 숨겨질테니! 아무튼 불편해서 추가했습니다! 수정/추가한 파일 menu.html my-style.scss 수정/추가한 파일_include/body/menu.html_sass/my-style.scssmenu.htmlnav.html에서처럼 _config.yml을 불러와서 추가해줬습니다.&lt;div id=\"_navbar\" class=\"navbar fixed-top\"&gt; &lt;div class=\"content\"&gt; &lt;span class=\"sr-only\"&gt;{{ site.data.strings.jump_to | default:\"Jump to\" }}{{ site.data.strings.colon | default:\":\" }}&lt;/span&gt; &lt;div class=\"nav-btn-bar\"&gt; &lt;a id=\"_menu\" class=\"nav-btn no-hover\" href=\"#_drawer--opened\"&gt; &lt;span class=\"sr-only\"&gt;{{ site.data.strings.navigation | default:\"Navigation\" }}&lt;/span&gt; &lt;span class=\"icon-menu\"&gt;&lt;/span&gt; &lt;/a&gt; &lt;div class=\"top-menu\"&gt; {% if site.menu %} {% for node in site.menu %} {% assign url = node.url | default: node.href %} &lt;a {% if forloop.first %}id=\"_drawer--opened\"{% endif %} href=\"{% include_cached smart-url url=url %}\" class=\"nav-btn top-menu {% if node.external %}external{% endif %}\" {% if node.rel %}rel=\"{{ node.rel }}\"{% endif %} &gt; {{ node.name | default:node.title }} &lt;/a&gt; {% endfor %} {% endif %} &lt;/div&gt; &lt;div class=\"nav-span\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;hr class=\"sr-only\" hidden /&gt;my-style.scsshydejack의 css 클래스를 찾아서 덮어쓰고 추가했습니다..top-menu-wrapper{ display: inline-block;}.nav-btn, .nav-btn-bar{ height: 3rem;}.top-menu{ overflow-x: auto; // overflow-y: hidden; white-space: nowrap;}.top-menu.nav-btn{ border: none; display: inline-flex; width: 6rem; margin-left: -1px;}.nav-btn:hover,.nav-btn:focus{ color: grey; background-color: rgba(0,0,0,0.05);}.nav-span{ flex: none;}" }, { "title": "How I customized Hydejack(4) - Sub Menu pop-over", "url": "/posts/how-i-customized-hydejack-4-popover/", "categories": "Etc", "tags": "hydejack, jekyll", "date": "2021-01-05 22:39:00 +0900", "snippet": "사이드바의 각 메뉴 아래에 서브 메뉴를 생성하는 방법지난 번 펼치기 글에서 서브메뉴를 만들었는데… 서브 메뉴가 많아지니까 스크롤이 생기는게 불편해서 팝오버로 다시 만들게 되었습니다! 수정/추가한 파일 Source nav.html sidebar-folder.js my-sty...", "content": "사이드바의 각 메뉴 아래에 서브 메뉴를 생성하는 방법지난 번 펼치기 글에서 서브메뉴를 만들었는데… 서브 메뉴가 많아지니까 스크롤이 생기는게 불편해서 팝오버로 다시 만들게 되었습니다! 수정/추가한 파일 Source nav.html sidebar-folder.js my-style.scss 수정/추가한 파일_includes/body/nav.htmlassets/js/sidebar-folder.js_sass/my-style.scss_includes/my-head.html_config.yml설명은 이전 글을 참고하시면 바로 이해될거라 생각하고 소스만 변경해서 첨부하겠습니다.+ 혹시 팝오버의 background-color 추천해주실분 추천 부탁드려요..Sourcenav.html&lt;span class=\"sr-only\"&gt;{{ site.data.strings.navigation | default:\"Navigation\" }}{{ site.data.strings.colon | default:\":\" }}&lt;/span&gt;&lt;ul&gt; {% if site.menu %} {% for node in site.menu %} {% assign url = node.url | default: node.href %} {% assign count = count | plus: 1 %} &lt;li&gt; &lt;div class=\"menu-wrapper\" onmouseover=\"javascript:spread({{count}})\" onmouseout=\"javascript:spread({{count}})\"&gt; {% if node.submenu %} &lt;button class=\"spread-btn\"&gt; &lt;span id=\"spread-icon-{{count}}\" class=\"material-icons\"&gt;arrow_right&lt;/span&gt; &lt;/button&gt; {% endif %} &lt;a {% if forloop.first %}id=\"_drawer--opened\"{% endif %} href=\"{% include_cached smart-url url=url %}\" class=\"sidebar-nav-item {% if node.external %}external{% endif %}\" {% if node.rel %}rel=\"{{ node.rel }}\"{% endif %} &gt; {{ node.name | default:node.title }} &lt;/a&gt; {% if node.submenu %} &lt;div id=\"submenu-{{count}}\" class=\"menu-wrapper submenu hide\"&gt; &lt;ul style=\"list-style: none;\"&gt; {% for subnode in node.submenu %} &lt;li&gt; &lt;a class=\"sidebar-nav-item {% if node.external %}external{% endif %}\" href=\"{% include_cached smart-url url=subnode.url %}\" &gt; {{ subnode.title }} &lt;/a&gt; &lt;/li&gt; {% endfor %} &lt;/ul&gt; &lt;/div&gt; {% endif %} &lt;/div&gt; &lt;/li&gt; {% endfor %}생략sidebar-folder.jsfunction spread(count){ let submenu = document.getElementById('submenu-' + count); if(submenu){ if(submenu.classList.contains('hide')) submenu.classList.remove('hide'); else submenu.classList.add('hide'); } let spreadIcon = document.getElementById('spread-icon-' + count); if(spreadIcon){ if(spreadIcon.innerHTML == 'arrow_right') { spreadIcon.innerHTML = 'arrow_drop_down'; spreadIcon.style.color = 'grey'; }else{ spreadIcon.innerHTML = 'arrow_right'; spreadIcon.style.color = 'white'; } }}my-style.scss생략.spread-btn{ left: 7%; position: absolute; padding: 0; padding-top: 2px; border: none; background: none; color: white; cursor: pointer;}.menu-wrapper { text-align: left; margin-left: 10%;}.submenu.menu-wrapper{ position: absolute; background-color: rgb(34,31,32); border-radius: 5px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.7); // width: 15rem; ul{ margin: 0; padding: 0 1.25rem; }}.submenu.menu-wrapper.hide{ display: none;}생략" }, { "title": "How I customized Hydejack(3) - Affixed TOC", "url": "/posts/how-i-customized-hydejack-3-affixed-toc/", "categories": "Etc", "tags": "hydejack, jekyll", "date": "2021-01-02 23:08:00 +0900", "snippet": "계속 따라오며 현재 보고 있는 목차는 bold 처리글의 목차(table of contents)가 스크롤을 할 때 따라오면 굉장히 편할 것 같아서 추가했습니다.hydejack pro버전에는 포함되어있는 기능같은데starter-kit에는 일부러 넣지 않은건지 동작하지 않아서 살짝 얹었습니다. 수정/추가한 파일 my-head.html ...", "content": "계속 따라오며 현재 보고 있는 목차는 bold 처리글의 목차(table of contents)가 스크롤을 할 때 따라오면 굉장히 편할 것 같아서 추가했습니다.hydejack pro버전에는 포함되어있는 기능같은데starter-kit에는 일부러 넣지 않은건지 동작하지 않아서 살짝 얹었습니다. 수정/추가한 파일 my-head.html Source 수정/추가한 파일_include/my-head.htmlmy-head.htmlmy-head.html에 있던 다른 모듈들의 시작이 모두document.querySelector('hy-push-state').addEventListener('load', () =&gt; {로 시작하는데 hy-push-state 여기에 설명이 되어있다.요약하자면 새 페이지를 불러들일 때, 하얀 배경이나 Unstyled 컨텐츠가 나타나는 일이 없이 새 페이지를 간지나게 로딩한다는 것 같다.한마디로 Turn static web sites into dynamic web apps라고 한다. 내가 이 부분에 꽂혀서 hydejack 테마를 쓰려고 github pages를 버리지 못하고 있다.어쩃든. 다시 돌아와서!이 hy-push-state의 load 이벤트를 이용하여 구현합니다.간단한 내용이라 어떻게 했는지만 요약하겠습니다!#markdown-toc element를 고정시키면 됩니다.고정 위치의 기준은 맨 처음에 toc element 위치에 relative div를 추가해두고 그 div의 위치를 계속 체크합니다.스크롤에서 벗어나게 되면 toc element에 affix 클래스를 추가합니다.그 반대 경우엔 affix 클래스를 제거하여 고정을 풀어줍니다.관련 자바스크립트는 제외했는데 왜 affix클래스는 있을까?같은 방법으로 헤더 태그들의 위치를 추적하며 현재 읽는 위치에 bold 스타일 추가 삭제해서 구현했습니다.Source&lt;script type=\"module\"&gt;document.querySelector('hy-push-state').addEventListener('load', () =&gt; { let tocElement = document.getElementById(\"markdown-toc\"); if(tocElement){ let affixedDiv = document.createElement(\"div\"); affixedDiv.style.position = \"relative\"; affixedDiv.style.top = \"-1rem\"; tocElement.parentNode.insertBefore(affixedDiv, tocElement); let headerList = document.getElementsByClassName(\"permalink\"); let prevElement; window.addEventListener(\"scroll\", () =&gt; { let hurdleTop = affixedDiv.getBoundingClientRect().top; if(hurdleTop &lt;= 0) tocElement.classList.add(\"affix\"); else tocElement.classList.remove(\"affix\"); for(let i=0;i&lt;headerList.length;i++){ if(headerList[i].getBoundingClientRect().top &gt;= 0){ prevElement?.style.removeProperty(\"font-weight\"); let tocId = \"markdown-toc-\" + headerList[i].parentNode.id; prevElement = document.getElementById(tocId); prevElement.style.fontWeight = \"bold\";; break; } } }); }});&lt;/script&gt;" }, { "title": "백준 1765 닭싸움 팀 정하기.java", "url": "/posts/boj1765/", "categories": "Algorithm, Problem Solving", "tags": "union-find", "date": "2021-01-02 17:13:00 +0900", "snippet": "문제누르면 이동합니다.문제 속 힌트 내 친구의 친구는 내 친구이다, 내 원수의 원수도 내 친구이다 친구이면 같은 팀에 속해있어야 하며 친구끼리 팀으로 묶는다. Union Find 입력에서, 입력은 모순이 없음이 보장된다. 즉, 두 학생이 동시에 친구이면서 원수인 경우는 없다.추가 조건Union-Find에서 아래 조건이 ...", "content": "문제누르면 이동합니다.문제 속 힌트 내 친구의 친구는 내 친구이다, 내 원수의 원수도 내 친구이다 친구이면 같은 팀에 속해있어야 하며 친구끼리 팀으로 묶는다. Union Find 입력에서, 입력은 모순이 없음이 보장된다. 즉, 두 학생이 동시에 친구이면서 원수인 경우는 없다.추가 조건Union-Find에서 아래 조건이 추가되었다. 친구 끼리만 같은 팀이 될 수 있다. 누군가의 원수의 원수는 친구다.원수를 제외하며 묶어야 한다. 풀이 보기 설명 원수의 원수는 친구다.만 해결하면 쉽다. 어떤 사람과 원수인 관계는 그 반대로도 적용되어야 한다. 예제에서, (1, 4)는 원수 (3, 5)는 친구 (4, 6)은 친구 (1, 2)는 원수 일단 친구 관계는 바로 묶어줘도 상관없다. 하나씩 그려보자. 이 상태에서, (1, 4) 원수 관계 (1, 2) 원수 관계를 추가 마지막 그림을 보면 2와 4는 같은 원수를 공유하고 있다.따라서 2와 4는 친구다! 결론 친구 관계는 바로 묶어준다. 원수인 경우 원수 관계로 추가 A - B 원수에서, 누군가 이미 A와 원수라면 누군가와 B는 친구다. 그 반대로도 친구다. 묶자. 코드 import java.util.HashSet;import java.util.Scanner;import java.util.Set;public class Main { static int[] friendSet; static int ans; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); friendSet = new int[n+1]; for(int i=1;i&lt;=n;i++) friendSet[i] = i; ans = n; int[] enemy = new int[n+1]; for(int i=0;i&lt;m;i++){ char type = sc.next().charAt(0); int n1 = sc.nextInt(); int n2 = sc.nextInt(); if(type == 'E'){// 원수인 경우. 원수에 추가하고 다른 원수랑 친구맺어주기 if(enemy[n1] == 0) enemy[n1] = n2; else{// enemy[n1], n2 유니온 union(enemy[n1], n2); } if(enemy[n2] == 0) enemy[n2] = n1; else{// enemy[n2], n1 유니온 union(enemy[n2], n1); } }else{// 친구인 경우. 그냥 union union(n1, n2); } } System.out.println(ans); } static int find(int idx){ if(friendSet[idx] == idx) return idx; return friendSet[idx] = find(friendSet[idx]); } static void union(int p1, int p2){ p1 = find(p1); p2 = find(p2); if(p1 != p2) { friendSet[p2] = p1; ans--; } }} " }, { "title": "백준 1185 유럽여행.java", "url": "/posts/boj1185/", "categories": "Algorithm, Problem Solving", "tags": "mst", "date": "2021-01-02 00:09:00 +0900", "snippet": "문제누르면 이동합니다문제 속 힌트 N개의 나라가 서로 연결된 것을 유지시키면서 ... N-1개의 길만을 남겨야할 것이다. 만드는 그래프는 모든 정점이 연결되어 있으며 사이클이 없는 그래프 모든 도시를 최소 한번 이상 방문하면서 최소 비용이 드는 방법MST 다추가 조건기본적인 MST에서 조건이 추가되었다. 길(엣지)을 지...", "content": "문제누르면 이동합니다문제 속 힌트 N개의 나라가 서로 연결된 것을 유지시키면서 ... N-1개의 길만을 남겨야할 것이다. 만드는 그래프는 모든 정점이 연결되어 있으며 사이클이 없는 그래프 모든 도시를 최소 한번 이상 방문하면서 최소 비용이 드는 방법MST 다추가 조건기본적인 MST에서 조건이 추가되었다. 길(엣지)을 지날 때 통행료 뿐만 아니라 각 나라(정점)의 입장료가 있다. 마지막 나라는 시작 나라이어야 한다 시작한 나라에서 그대로 다시 돌아와야 한다 어떻게 정점에 있는 가중치까지 고려해서 MST를 만들 수 있을까? 풀이 보기 설명 아래 세 가지에 집중해보자. N개 정점, N-1개의 간선으로 이루어진 그래프가 만들어진다. 그리고 모든 정점이 사이클 없이 연결되어 있다. 어떤 시작점에서 출발하더라도 시작점으로 다시 돌아와야 한다. 우선 시작점만 생각해보자. 시작점이 어디고 어디로 가든 다시 돌아와야 한다. 다음 정점에선 어떨까? 앞에서 어떤 경로를 지나왔는지에 관계 없이 왔던 길로 돌아가야 한다.다시말해서, X정점에서 길을 지나 Y정점에 도착했다면 다시 같은 길을 지나 X로 돌아가야한다. Y정점에서 다른 길을 통해 X정점으로 돌아가는 길은 없기 때문이다. 문제 아래에 있는 힌트를 그린 그림 예제에서 민식이가 이동한 경로인데 왔던 길을 다시 돌아가는 것을 볼 수 있다. 결론 처음 시작할 때부터 입장료를 받는다는 것을 기억 X정점의 입장료 + Y정점의 입장료 + 두 정점 사이의 통행료 * 2를 간선의 가중치로 두고 MST를 만들면 된다. 또한 어느 정점에서 시작하더라도 위와 같은 형태로 여행해야 하기 때문에 첫 입장료에 따라 총 비용이 달라지게 된다. 그러므로 입장료가 가장 싼 정점부터 시작하도록 하자. 코드 public class Main { static class Item{ int from, to, cost; public Item(int from, int to, int cost) { this.from = from; this.to = to; this.cost = cost; } } static int[] nationSet; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); int n = Integer.parseInt(st.nextToken()); int p = Integer.parseInt(st.nextToken()); nationSet = new int[n+1]; for(int i=1;i&lt;=n;i++) nationSet[i] = i; int[] fee = new int[n+1]; int minFee = Integer.MAX_VALUE; for(int i=1;i&lt;=n;i++) { fee[i] = Integer.parseInt(br.readLine()); minFee = Math.min(minFee, fee[i]); } PriorityQueue&lt;Item&gt; pq = new PriorityQueue&lt;&gt;((o1, o2)-&gt;{ return Integer.compare(o1.cost, o2.cost); }); for(int i=0;i&lt;p;i++){ st = new StringTokenizer(br.readLine()); int from = Integer.parseInt(st.nextToken()); int to = Integer.parseInt(st.nextToken()); int cost = Integer.parseInt(st.nextToken()); cost = fee[from] + fee[to] + cost + cost; pq.add(new Item(from, to, cost)); } int ans = 0; while(!pq.isEmpty()){ Item edge = pq.poll(); if(union(edge.from, edge.to)){ n--; ans += edge.cost; if(n == 1) break; } } System.out.println(ans + minFee); } static int find(int idx){ if(idx == nationSet[idx]) return idx; return nationSet[idx] = find(nationSet[idx]); } static boolean union(int n1, int n2){ n1 = find(n1); n2 = find(n2); if(n1 == n2) return false; nationSet[n2] = n1; return true; }} " }, { "title": "How I customized Hydejack(2) - Sub Menu 펼치기", "url": "/posts/how-i-customized-hydejack-2-spread/", "categories": "Etc", "tags": "hydejack, jekyll", "date": "2020-12-28 23:08:00 +0900", "snippet": "사이드바의 각 메뉴 아래에 서브 메뉴를 생성하는 방법수정/추가한 파일_includes/body/nav.htmlassets/js/sidebar-folder.js_sass/my-style.scss_includes/my-head.html_config.ymlnav.htmlSource&lt;span class=\"sr-only\"&gt;{{ site.data.st...", "content": "사이드바의 각 메뉴 아래에 서브 메뉴를 생성하는 방법수정/추가한 파일_includes/body/nav.htmlassets/js/sidebar-folder.js_sass/my-style.scss_includes/my-head.html_config.ymlnav.htmlSource&lt;span class=\"sr-only\"&gt;{{ site.data.strings.navigation | default:\"Navigation\" }}{{ site.data.strings.colon | default:\":\" }}&lt;/span&gt;&lt;ul&gt; {% if site.menu %} {% for node in site.menu %} {% assign url = node.url | default: node.href %} {% assign count = count | plus: 1 %} &lt;li&gt; &lt;div class=\"menu-wrapper\"&gt; {% if node.submenu %} &lt;button class=\"spread-btn\" onclick=\"javascript:spread({{count}})\"&gt; &lt;span id=\"spread-icon-{{count}}\" class=\"material-icons\"&gt;arrow_right&lt;/span&gt; &lt;/button&gt; {% endif %} &lt;a {% if forloop.first %}id=\"_drawer--opened\"{% endif %} href=\"{% include_cached smart-url url=url %}\" class=\"sidebar-nav-item {% if node.external %}external{% endif %}\" {% if node.rel %}rel=\"{{ node.rel }}\"{% endif %} &gt; {{ node.name | default:node.title }} &lt;/a&gt; &lt;/div&gt; {% if node.submenu %} &lt;div class=\"menu-wrapper\"&gt; &lt;input type=\"checkbox\" id=\"folder-checkbox-{{count}}\"&gt; &lt;ul&gt; {% for subnode in node.submenu %} &lt;li&gt; &lt;a class=\"sidebar-nav-item {% if node.external %}external{% endif %}\" href=\"{% include_cached smart-url url=subnode.url %}\" &gt; {{ subnode.title }} &lt;/a&gt; &lt;/li&gt; {% endfor %} &lt;/ul&gt; &lt;/div&gt; {% endif %} &lt;/li&gt; {% endfor %}생략코드 설명sub-menu 버튼생략&lt;!-- 복수의 메뉴 각각을 식별하기 위한 인덱스 --&gt;{% assign count = count | plus: 1 %}&lt;li&gt; &lt;div class=\"menu-wrapper\"&gt; &lt;!-- submenu 변수는 아래 _config.yml 에서 추가합니다 --&gt; {% if node.submenu %} &lt;!-- spread 함수는 js 파일로 작성하고 my-head.html에 추가합니다 --&gt; &lt;!-- spread-btn class는 my-style.scss에 추가합니다. --&gt; &lt;button class=\"spread-btn\" onclick=\"javascript:spread({{count}})\"&gt; &lt;!-- marterial stylesheet를 my-head.html에 추가합니다 --&gt; &lt;span id=\"spread-icon-{{count}}\" class=\"material-icons\"&gt;arrow_right&lt;/span&gt; &lt;/button&gt; {% endif %}생략sub-menu list생략{% if node.submenu %} &lt;div class=\"menu-wrapper\"&gt; &lt;!-- 접힘/펼침 여부를 체크박스로 관리합니다 --&gt; &lt;input type=\"checkbox\" id=\"folder-checkbox-{{count}}\"&gt; &lt;ul&gt; {% for subnode in node.submenu %} &lt;li&gt; &lt;a class=\"sidebar-nav-item {% if node.external %}external{% endif %}\" href=\"{% include_cached smart-url url=subnode.url %}\" &gt; {{ subnode.title }} &lt;/a&gt; &lt;/li&gt; {% endfor %} &lt;/ul&gt; &lt;/div&gt;{% endif %}생략sidebar-folder.jsSourcefunction spread(count){ // check 상태와 화살표 방향을 변경합니다. document.getElementById('folder-checkbox-' + count).checked = !document.getElementById('folder-checkbox-' + count).checked document.getElementById('spread-icon-' + count).innerHTML = document.getElementById('spread-icon-' + count).innerHTML == 'arrow_right' ? 'arrow_drop_down' : 'arrow_right'}my-style.scssSource생략.spread-btn{ left: 7%; position: absolute; padding: 0; padding-top: 2px; border: none; background: none; color: white; cursor: pointer;}.spread-btn:hover{ color: grey;}.menu-wrapper{ display: flex; text-align: left; margin-left: 10%; input[type=checkbox]{ display: none; } input[type=checkbox] ~ ul{ display: none; list-style: none; } input[type=checkbox]:checked ~ ul{ display: block; }}생략my-head.htmlSource생략&lt;link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\" rel=\"stylesheet\"&gt;&lt;script src=\"/assets/js/sidebar-folder.js\"&gt;&lt;/script&gt;생략_config.yml이제 _config.yml에서 menu 속성을 변경하면 서브 메뉴를 사용할 수 있습니다.Source생략menu: - title: Project url: /project/ - title: Docs url: /docs/ submenu: - title: Java url: /java/ - title: Spring url: /spring/ - title: Computer Science url: /computer-science/ - title: Algorithm url: /algorithm/ submenu: - title: Theory url: /theory/ - title: Problem Solving url: /problem-solving/ - title: Log url: /log/ submenu: - title: Develop url: /develop/ - title: Book url: /book/ - title: Guitar url: /guitar/ - title: About url: /about/생략 이 블로그의 메뉴 구조입니다" }, { "title": "How I customized Hydejack(1) - Use LiveReload", "url": "/posts/how-i-customized-hydejack-1/", "categories": "Etc", "tags": "hydejack, jekyll", "date": "2020-12-26 05:40:00 +0900", "snippet": "windows 환경 local에서 blog 작업 후 한 번에 반영하기로 하면서 livereload를 사용하고 싶었으나 hydejack starter kit bundle에 포함되어 있음에도 오류와 함께 실행되지 않았다. 그 해결 방법을 정리합니다. Prerequisite 원인 시도한 방법 해결 방법 다른 방법Prerequisite RubyI...", "content": "windows 환경 local에서 blog 작업 후 한 번에 반영하기로 하면서 livereload를 사용하고 싶었으나 hydejack starter kit bundle에 포함되어 있음에도 오류와 함께 실행되지 않았다. 그 해결 방법을 정리합니다. Prerequisite 원인 시도한 방법 해결 방법 다른 방법Prerequisite RubyInstaller 에서 ruby+devkit 설치 gem install bundler로 bundler 설치원인 livereload설치 시 platform 옵션으로 ruby, x64-mingw32를 적용하고 있는데.. Gemfile의 platform 옵션이 제대로 적용되지 않는 것 같다.시도한 방법 Gemfile.lock에 platform 옵션 추가 bundle lock --add-platform ruby bundle lock --add-platform x64-mingw32 이 명령은 시도해보지 않았지만 작성 중 생각해보니 이게 제대로 된 해결 방법일 것 같다는 느낌이 듭니다. 추후에 시도 해보고 수정하겠습니다. 안됨! 해결 방법 gem install eventmachine --platform=ruby %ruby_path%\\lib\\ruby\\gems\\2.7.0\\gems\\eventmachine CTRL+C %your_hydejack_path%\\vendor\\bundle\\ruby\\2.7.0\\gems에 eventmachine-{version}-x64-mingw32로 이름 변경 후 CTRL+V bundle exec jekyll serve --livereload 실행 하면 정상적으로 동작하는 것을 확인 가능 hydejack에선 이렇게 해결했었으나 현재 테마에선 적용이 어려워 다른 방법을 찾았는데 매우 간단하다.Gemfile에 gem 'eventmachine', '1.2.7', git: 'https://github.com/eventmachine/eventmachine', tag: 'v1.2.7' 한 줄 추가해주면 된다._config.yml는 자동 반영되지 않습니다.다른 방법 linux 환경에서 작업 WSL 설치 후 rbenv, rvm 과 같은 가상 컨테이너를 사용 물론 시도해보지 않았음. 언젠가 ruby를 배워보고 싶을 때나 해볼듯" } ]
