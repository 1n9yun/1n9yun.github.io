---
layout: post
title: STEW - Cam Study Platform
description: >
  --- 2020. 07. 13. ~ 2020. 08. 21.
  <br><br>
  **TEAM 어묵간장조**  

  엄홍재(팀장) : 프로젝트 총괄, Frontend - webRTC, 일정, 타이머, 반응형 제작  

  김송희 : Fullstack - Backend, 알림 소켓, Frontend - UI/UX  

  민강규 : Frontend - 그룹 기능, 채팅, 알림 개발, UI/UX  

  **정인균 : Backend, Frontend - Authentication / Authorization / OAuth2**  

  조희진 : Frontend - Authentication / Authorization
  <br><br>
  언택트 시대를 맞은 학습의 변화 가운데 **'언제 어디서나 함께 공부할 수 있게 하자(STudy EveryWhere)'**라는 목표를 가지고 온라인 캠 스터디 플랫폼인 STEW를 제작하였습니다.
  <br><br>
  ![Springboot](https://img.shields.io/badge/-Springboot-green)
  ![Vue](https://img.shields.io/badge/-Vue-%2342b883)
  ![MySQL](https://img.shields.io/badge/-MySQL-blue)
  ![MariaDB](https://img.shields.io/badge/-MariaDB-blue)
  ![Redis](https://img.shields.io/badge/-Redis-red)
  ![Docker](https://img.shields.io/badge/-Docker-0db7ed)
  ![NGINX](https://img.shields.io/badge/-NGINX-00984b)
  ![Jenkins](https://img.shields.io/badge/-Jenkins-red)
  ![Node.js](https://img.shields.io/badge/-Node.js-%2342b883)
  ![WebRTC](https://img.shields.io/badge/-WebRTC-lightgrey)

related_posts:
  # - project/_posts/2012-02-07-test-content.md
comments: true
---
<!-- blank -->
0. this unordered seed list will be replaced by toc as unordered list
{:toc}

## 소개
<div id="stew-carousel" class="swiper-container"></div>
<script>
  swiperInitialize("stew-carousel", {
    path: "/img/project/stew",
    imgList: [
      "main.jpeg",
      "register-normal.jpeg", 
      "register-social.jpeg",
      "login.jpeg",
      "study-list.jpeg",
      "study-list-search.jpeg",
      "study-participate.jpeg",
      "study-private-accept.jpeg",
      "study-create.jpeg",
      "study-detail-1.jpeg",
      "study-detail-2.jpeg",
      "cam-study-ready.jpeg",
      "cam-study.jpeg",
      "mypage-1.jpeg",
      "mypage-2.jpeg",
      "mypage-3.jpeg",
      "guide.jpeg"
    ],
    dotted: false,
    millis: 4000
  })
</script>

### 주요 기능
* 무한 스크롤 - <a href="javascript:slideTo(4)">메인 페이지의 스터디 목록</a>
* 웹 소켓 - <a href="javascript:slideTo(7)">알림</a>, <a href="javascript:slideTo(12)">채팅</a>
* WebRTC - <a href="javascript:slideTo(12)">실시간 스트리밍</a>
* Spring Security - 사용자 <a href="javascript:slideTo(3)">인증</a>, 인가, <a href="javascript:slideTo(2)">소셜 로그인</a>

### ERD
<img src="/assets/img/project/stew/erd.jpg">

## 회고
### 수행 역할
* SpringSecurity, JWT를 이용한 User Authentication, Authorization  
* Spring OAuth2를 이용한 SNS 로그인  
* 인증 API로 상호작용하는 Frontend  

#### SpringSecurity과 JWT를 이용한 사용자 인증/인가 

다른 인증 방식과의 비교는 <a href="javascript:alert('아직이욥! ㅎㅎ;ㅈㅅ...ㅋㅋ!!')">여기</a>에 정리합니다.  
<!-- HTTP는 연결 지향 프로토콜인 TCP 기반임에도 불구, 대표적인 비 연결 지향 프로토콜입니다. 한 번의 요청 - 응답 사이클이 완료되면 연결을 종료하기 대문에 각각의 요청은 모두 독립적인 요청으로 인지합니다. 따라서 클라이언트는 매 요청에 인증 정보를 포함시켜야 하며 서버 또한 이를 기반으로 인증 과정을 거쳐야 합니다.  
ex) 사용자 A가 작성한 게시글을 다른 사용자가 마음대로 수정/삭제할 수 없음 ([여기] 문서에 추가하자) -->
{:.note}
##### JWT 도입 이유
  다른 인증 방식과 비교 하여 서버 사이드의 별다른 저장소가 필요 없다는 점, 클라이언트와 서버의 연결고리가 없으므로 서버 확장성과 유지 보수측면에서 장점이 있어 Stateless Server에 보다 적절한 방식이라고 생각됩니다.
  또한 스마트폰, 태블릿과 같은 모바일 환경에서의 서비스도 고려했기 때문에 토큰 기반 인증이 적절하다고 생각했습니다.(쿠키 기반 인증의 경우 쿠키 컨테이너를 사용해야 함?)
###### 인증 정보의 위치 결정
우선 아래와 같은 조건을 생각합니다.  
* **모든 형태의 HTTP 요청에 사용** 가능해야 한다. (`GET`, `POST`, `PUT`, `DELETE` ...)
* 클라이언트 사이드에서 **쉽게 저장**하고 HTTP 요청 시 **쉽게 데이터를 실어줄** 수 있어야 한다.  

선택지는 request body, query parameter, cookie header, authorization header가 있었고 아래와 같은 이유로 **Authorization header**로 결정하였습니다.
* 인증 데이터는 metadata 성격이 강하여 **request body와 어울리지 않는다.**
* 게다가, `GET`, `HEAD`, `DELETE`, `TRACE`와 같은 메소드는 **request body를 사용할 수 없다.**
* 표준화 되어있는 Authorization Header 대신 **query string을 써서 얻을 메리트가 없다.**
* cookie header와 authorization header의 경우는 query string을 걸렀던 이유와 비슷하게 **인증이라는 맥락에서 authorization header가 어울린다.**

###### 인증 스키마
[MDN docs - Authorization header](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Authorization){: target="_blank"}  
[Bearer Spec - RFC6750](https://tools.ietf.org/html/rfc6750){: target="_blank"}
{:.note title="Prerequisite"}
이전(로그인 시 서버는 해당 사용자를 나타내는 특별한 값을 만들어 전달하여 권한을 부여하고 사용자는 나중에 Authorization header로 그 인증 데이터를 보내주는 것)까지의 과정이 결정되었고 이제 **'사용자를 나타내는 특별한 값'**을 어떻게 만들어낼 지는 표준이 결정해 줄 것입니다.

authorization header의 값인 `<type> <credentials>`에서 인증 type에 따라 **credential을 만들어내는 방식이 정해져** 있기 때문에 인증 스키마에 대한 의사 결정이 필요합니다. 아래와 같은 조건을 생각합니다.
* 표준을 따르지 않는다면 **충분한 이유와 대안이 필요**하다.
* 확장 가능성을 위해 **토큰 기반 인증 시스템이면 좋다**.
* 충분히 **암호화된 상태**로 주고받을 수 있거나, 비밀번호와 같이 **민감한 데이터를 값 내부에 포함시키지 않는 방식**이어야 한다.

표준 상 authorization header 값에는 **RFC에 의해 표준화**된 인증 스키마를 사용할 수 있게 되어있습니다.   
따라서 다음의 선택지에서 선택하겠습니다.
* Basic
* (non-standard) OAuth 1.0a를 사용하는 Bearer
* OAuth 2.0을 사용하는 Bearer
* (non-standard) JWT, JWT를 사용하는 Bearer
* Digest
* HOBA  

아래와 같은 이유로 JWT를 사용하는 Bearer를 선택합니다.  
* Basic은 사용자ID와 비밀번호를 콜론을 이용하여 합친 후 `base64`로 인코딩합니다. 하지만 **base64는 별도의 key 없이 복호화가 가능한 인코딩**이므로 안전하지 않다.
* OAuth 1.0a는 Bearer 인증 표준이 아니다.
* Bearer에서 사용하는 OAuth 2.0 방식은 확장성이 매우 높다. 그러나 **자체 암호화를 지원하지 않기** 때문에 **HTTPS를 쓰는 것을 권고**하고 있으며 **비용 문제가 발생**한다. *(letsencrpyt에서 무료 SSL 인증서를 발급 받을 수 있다. 당시에 알았다면 OAuth 2.0 방식을 시도했을 것 같다.)* 또한 스펙 자체에서 명확하게 정의하지 않은 부분이 꽤 있어 고민이 깊어진다고 한다 ?
* 하지만 **Bearer에 JWT, JWT라는 타입을 쓰는 것도 표준이 아니다.** 그러나 **OAuth 2.0을 보류**하게 되어 대신 쓸 토큰 기반 인증 시스템으로 **JWT가 적절**하다고 생각했다.
* JWT는 자료(사례, 라이브러리, 예제 등)가 많다.

##### The way I Implemented

SpringSecurity Architecture (제공되는 Interface, Implementations ...) 는 <a href="javascript:alert('아직이욥! ㅎㅎ;ㅈㅅ...ㅋㅋ!!')">여기</a>에 정리합니다.  
[SpringSecurity docs - Authentication ...](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-authentication){: target="_blank"}
{:.note title="prerequisite"}

###### 흐름 파악

아래와 같은 구조로 Authentication을 구현합니다.
![SpringSecurity Architecture](https://chathurangat.files.wordpress.com/2017/08/blog-post-spring-security-basic-authentication-3.png)
