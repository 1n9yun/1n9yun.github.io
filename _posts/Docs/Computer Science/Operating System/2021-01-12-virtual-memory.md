---
layout: post
title: 가상 메모리
category:
    - docs
    - computer-science
tags:
    - operating-system
description: >

---
<!-- blank -->
* toc
{:toc}

<u>물리 메모리 공간보다 큰 공간이 필요한 프로세스를 실행하기 위해서</u> 탄생했다.  

가상 메모리에서 메모리 관리자가 사용할 수 있는 메모리의 <u>전체 크기는 물리 메모리와 스왑 영역을 합한 것과 같다.</u>  

프로그램을 분할한 다음 <u>사용하는 것만 물리 메모리에 올리고 사용하지 않는 것은 디스크(가상 메모리)에 저장한다.</u>  

## 요구 페이징
가상 메모리에서 프로그램 실행을 위해 초기에 필요한 것만 적재하는 기법.  
실제 필요한 페이지들만 메모리로 읽어오므로 시간과 메모리의 낭비를 줄일 수 있다.  
프로세스가 메모리에 올라와 있지 않은 페이지를 접근하려고 하면 페이지 폴트 트랩을 발생시킨다.  

## 페이지 폴트(Page Fault)
페이지 폴트가 발생하면 원하는 페이지를 저장 장치에서 가져오게 되고 만약 물리 메모리가 가득 차있는 상태라면 페이지 교체가 이루어진다.

### 과정
* 프로세스에 대한 내부 테이블을 검사해서 그 메모리 참조가 유효한지 검사
* 유효하지 않은 참조라면 해당 프로세스는 종료되고, 유효한 참조인데 페이지가 아직 메모리에 올라오지 않았다면 디스크로부터 가져와야 한다.
* 빈 공간을 찾는다.
* 디스크에 새로 할당된 프레임으로 해당 페이지를 읽어 들이도록 요청한다.
* 디스크 읽기가 끝나면 이 페이지가 이제는 메모리에 있다는 것을 알리기 위해 페이지 테이블을 갱신하고 프로세스가 유지하고 있는 내부 테이블을 수정한다.
* 트랩에 의해 중단되었던 명령을 다시 수행

## 페이지 교체 알고리즘
### FIFO
* 선입 선출
    * 물리 메모리에 올라온 순서대로 페이지 교체 시점에 나가게 됨
* 큐를 이용한 쉬운 구현

### 최적 페이지 교체(Optimal Page Replacement)
* 가장 오랫동안 **사용되지 않을** 페이지를 찾아 교체
* 낮은 페이지 부재율을 보장하지만 구현이 어렵다.

### LRU(Least-Recently-Used Page Replacement)
* 가장 오랫동안 **사용되지 않은** 페이지를 선택해 교체

### LFU(Least Frequently Used)
* 참조 횟수가 가장 적은 페이지를 교체
* 교체 대상이 여러개인 경우 LRU를 사용
* 처음에 집중적으로 참조하다가 이후에 참조하지 않는 경우 계속 메모리에 남을 수 있다는 문제점

### MFU(Most Frequently Used)
* 참조 횟수가 가장 많은 페이지를 교체

## 메모리 단편화
### 내부 단편화
교체된 페이지의 크기가 할당된 공간의 크기보다 작은 경우 저장 공간이 낭비

### 외부 단편화
메모리가 할당되고 해제되는 과정에서 작은 메모리가 중간중간 존재하게 되는데 이 때 총 메모리 공간은 충분하지만 교체된 페이지의 크기가 할당된 공간의 크기보다 큰 경우

### 해결
#### 페이징
* 외부 단편화 해결 방법
* 페이지가 연속적인 물리 메모리 공간에 들어가야하는 제약을 해결하기 위한 방법
* 가상 메모리는 페이지, 물리 메모리는 프레임이라는 고정 크기의 블록으로 나눈다.
* 페이지 테이블의 매핑을 통해 1:1 대응  

페이지 단위를 작게하면 내부 단편화 역시 해결할 수 있지만 페이지에 공간을 할당한 후 남는 공간이 적어지기 때문에 그만큼 page mapping 과정이 증가할 수 있다.

#### 세그먼테이션
* 내부 단편화 해결 방법

프로그램의 논리적 단위를 바탕으로 서로 다른 크기의 블록으로 나누는 방법

서로 다른 크기의 세그먼트들에 대해 필요 시에 메모리에 올리고, 필요없을 경우 내리는 작업을 반복하다보면 외부단편화가 생기는 문제점이 있다.