---
layout: post
category: 
  - docs
  - computer-science
tags: operating-system
title: Process, Thread
description: >
  프로세스와 스레드에 대한 내용 정리
---
<!-- blank -->
{% assign post_vars = site.data['post_vars'] %}
![thread process]({{ post_vars.os.imgpath }}/thread_process.gif)
from IBM knowledgecenter
{:.figcaption}

* toc
{:toc}

## Process
간단히, **실행중인 프로그램**  

사용자가 작성한 프로그램이 운영체제에 의해 메모리 공간을 할당받아 실행 중인 것

### 구조
* Code 영역 - 프로그램을 실행시키는 실행 파일 내의 명령어들이 올라감 (**소스코드**)
* Data 영역 - **전역 변수, static 변수**의 할당
* Heap 영역 - **동적할당**을 위한 메모리 영역
* Stack 영역 - **지역변수**, 함수 호출 시 전달되는 **파라미터**를 위한 메모리 영역
  * 함수 호출 시 스택의 모습은? or 재귀 호출 시?

### Context Switching
<!-- 컨텍스트 스위칭은 스레드 단위에서 이루어지는 것? -->
* 인터럽트에 의해 다음 우선 순위의 프로세스가 실행되어야할 때 기존 프로세스의 상태 또는 레지스터 값을 저장,
* 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값을 교체하는 작업

### Multi-Processing
* 하나의 프로그램을 여러 프로세스로 구성하여 `Context Switching`을 통해 실행하는 것
* 하나의 프로세스에 문제가 생기더라도 **다른 프로세스에 영향을 미치지 않는다.**
  * 한편, 다른 프로세스의 변수나 자료 구조에 접근할 수 없다.
    * IPC(inter-process-communication)을 사용해야 한다. (파이프, 파일, 소켓 등)

### 교착 상태
서로 다른 프로세스가 서로의 자원을 요구하며 무한정 기다리는 현상

#### 조건
* **상호 배제** - 한 번에 한 프로세스만이 자원을 점유할 수 있다.
* **점유 대기** - 프로세스가 이미 자원을 점유하는 상태에서 다른 자원을 무한정 기다린다.
* **비선점** - 프로세스가 어떤 자원의 점유를 끝낼 때까지 그 자원을 뺏을 수 없다.
* **순환 대기** - 각 프로세스들이 원형으로 구성되어 순환적으로 자원을 요구한다.

## Thread
프로세스 내에서 실제로 작업을 수행하는 주체

모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행한다.
* 프로세스가 실행되면 기본적으로 하나의 메인 스레드가 생성된다.
* 프로세스 내에서 각각 Stack만 따로 할당받고 나머지 Code, Data, Heap영역을 공유한다.

### Multi-Threading
* 프로그램을 한 프로세스 내에 여러 개의 스레드로 구성하여 실행하는 것
* 멀티 프로세스보다 멀티 스레드가 효율적이다.
  * 스레드 간의 통신 비용이 훨씬 적기 때문
* 동기화에 신경써야 한다.
  * 스레드 간에 공유되는 자원을 사용하면서 다른 스레드의 작업에 영향을 주기 때문
* 웹 서버가 대표적인 Multi Threaded Application

N개의 스레드가 공유 자원에 접근할 때 문제가 생길 수 있다. (입출금 문제 등..)  

추가로, [Concurrent Programming](/docs/java/2021-01-06-concurrent-programming/)
{:.note}

#### 동시성 (Concurrency)
**하나의 코어에서 멀티 스레드를 동작**시키기 위한 방식.  
여러 개의 스레드가 번갈아가면서 실행되는 성질이다.  
스레드들이 병렬적으로 실행되는 것 처럼 보이지만 사실은 번갈아가면서 조금씩 실행되고 있는 것.  

#### 병렬성 (Parallelism)
**멀티코어에서 멀티 스레드를 동작**시키는 방식.  
한 개 이상의 스레드를 포함하는 각 코어들이 동시에 실행되는 성질.  

##### 데이터 병렬성(Data parallelism)
전체 데이터를 쪼개 서브 데이터들로 만든 뒤, **서브 데이터들을 병렬 처리**하여 작업을 빠르게 수행하는 것.  
<!-- parallelStream 장애 사례 https://multifrontgarden.tistory.com/254 -->
`Java 8`에서 지원하는 `ParallelStream`이 이것을 구현한 것이다.  
서브 데이터는 **멀티 코어의 수만큼 쪼개어 각각의 데이터들을 분리된 스레드에서 병렬 처리**한다.

##### 작업 병렬성(Task parallelism)
**서로 다른 작업을 병렬 처리**하는 것.  

대표적으로 **웹 서버 어플리케이션**이 있다.  
각각의 브라우저에서 **요청한 내용을 개별 스레드에서 병렬로 처리**한다.

[~~Blocking I/O & non-Blocking I/O~~](javascript:console.log('아직'))
{:.note title="참고"}

### Thread Pool
* 특정 스레드 개수 + 작업 큐를 만들어 놓고 **작업들을 큐에 넣어 둔다.**  
* **작업이 끝난 스레드가 큐에서 작업을 꺼내** 기능을 수행하도록 한다.  

아무리 요청이 폭주해도 스레드의 전체 개수가 늘어나지 않기 때문에 **어플리케이션의 성능이 급격히 저하되지 않는다.**  

<!-- 스레드 풀 정리하기 https://honbabzone.com/java/java-thread/ -->
[~~자세한 내용~~](javascript:console.log("아직"))

## Scheduling
일반적으로 `CPU 스케줄링`, `프로세스 스케줄링`은 같은 개념으로 사용한다.  
* 반환시간 : 프로세스가 완전히 종료되어 CPU를 반환한 시간
* 대기시간 : 기다린 시간의 총합
{:.note}

* CPU의 <u>이용률과 처리율을 최대화</u>하기 위해 항상 실행 중인 프로세스를 가지게 하는데 목적이 있다.  
* CPU가 유휴 상태가 될 때마다 운영체제는 Ready Queue에 있는 프로세스 중에서 **하나를 선택해 실행해야 한다.**
* CPU 스케줄러는 **실행 준비가 되어있는 메모리 내의 프로세스** 중에서 선택하고 이들 중 하나에게 CPU를 할당한다.
* Ready Queue에 있는 **레코드들은 일반적으로 프로세스 제어 블록(PCB)이다.**

CPU 스케줄링의 결정은 다음의 네 가지 상황에서 발생할 수 있다.
* 프로세스가 <u>실행 상태에서 대기 상태로 전환</u>될 때 (I/O 발생)
* 프로세스가 <u>실행 상태에서 준비 완료 상태로 전환</u>될 때 (인터럽트 발생)
* 프로세스가 <u>대기 상태에서 준비 완료 상태로 전환</u>될 때 (I/O 종료)
* 프로세스가 <u>종료</u>될 때

### Dispatcher
**스케줄러가 선택한 프로세스에 CPU 코어의 제어를 주는 모듈**
아래와 같은 작업을 진행한다.
* 한 프로세스에서 다른 프로세스로 문맥을 교환하는 일
* 사용자 모드로 전환하는 일
* 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동하는 일

`Dispatcher`가 하나의 프로세스를 정지하고 다른 프로세스의 수행을 시작하는데까지 소요되는 시간을 `Dispatch latency`라고 한다. (`Context Switching`과정)  

### 비선점 스케줄링
일단 CPU가 한 프로세스에 할당되면 프로세스가 종료되거나 대기 상태로 전환하여 <u>CPU를 반환할 때 까지 점유</u>한다.

### 선점 스케줄링
시분할 시스템에서 타임 슬라이스가 소진되었거나 인터럽트나 시스템 호출 종료시에 더 높은 우선 순위 프로세스가 발생 되었음을 알았을 때 <u>현 실행 프로세스로부터 강제로 CPU를 회수하는 것을 말한다.</u>
* 데이터가 다수의 프로세스에 의해 공유될 때 `racing condition`이 발생될 수 있다.
* mutex lock, monitor 등의 기법을 통해 `racing condition`을 피한다.

**경쟁 상태**란 둘 이상의 입력 또는 <u>조작의 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태</u>를 말한다.
{:.note title="Racing Condition ?"}

### 알고리즘
#### 선입선처리 (FCFS)
* **먼저 요청하는 프로세스가 CPU를 먼저 할당**
* 평균 대기 시간이 매우 길어질 수 있다. (<u>대화형 시스템에 적절하지 않다.</u>)
* 비선점형 알고리즘

#### 최단 작업 우선 (SJF)
* **CPU burst 길이가 가장 작은 프로세스부터 순차적으로 CPU 코어를 할당**
* 주어진 프로세스 집합에 대해 최소의 평균 대기 시간을 가진다는 점에서 <u>최적</u>임을 증명할 수 있다.
  * 하지만 각 프로세스의 **CPU burst 길이를 알 수 있는 방법이 없으므로** 예측해서 스케줄링 해야한다.
* 선점일수도, 비선점형일 수 있다.

#### SRTF (Shortest Remaining Time First)
* **SJF에서 선점 정책을 도입한 것**
* 프로세스의 실행 중에 더 짧은 실행시간을 가진 프로세스가 들어오면 선점한다.
* 잦은 실행시간 계산과 잦은 문맥교환으로 인한 오버헤드 문제

#### 라운드 로빈 (RR)
* FCFS와 유사하지만 **시스템이 프로세스들 사이를 옮겨다닐 수 있도록 선점이 추가된다.**  
* 시간 할당량(time quantum) / 타임 슬라이스라고 하는 <u>작은 단위의 시간을 정의하고 이 단위 시간 동안 CPU를 할당한다.</u>
* 선점형 알고리즘

시간 할당량이 **매우 크면 RR은 FCFS와 같아지게 된다.** 반대로 **매우 적다면 매우 많은 문맥 교환을 야기**할 것이다.  
<u>문맥에 적절한 시간 할당량의 크기를 설정해야 한다.</u>

#### 우선순위 (Priority Scheduling)
* **우선 순위가 가장 높은 프로세스에 CPU를 할당**
* 우선 순위를 결정함에 있어 주요 문제는 `무한 봉쇄(indefinite)`, `기아 상태(starvation)`이다.
  * 실행 준비는 되어 있으나 CPU를 사용하지 못하는 프로세스는 <u>CPU를 기다리면서 봉쇄된 것으로 간주할 수 있다.</u> (Blocking)
  * 부하가 심한 컴퓨터 시스템에서는 높은 우선순위의 프로세스들이 꾸준히 들어와서 <u>낮은 우선순위의 프로세스들이 CPU를 영원히 얻지 못하게 될 수도 있다.</u> (Stavation)

낮은 우선순위의 프로세스들이 무한히 봉쇄되는 문제에 대한 한 가지 해결방안은 `노화(aging)`이다. (**오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가시키는 방법**)  
또 다른 방법은 RR과 결합하는 방법이다.

#### HRN (Highest Response ratio Next)
* **핸슨(Brinch Hansen)이 제안한 비선점, 우선순위 스케줄링 알고리즘**  
* 우선순위를 <u>서비스를 받을 시간 뿐만 아니라 기다린 시간의 함수로 나타낸다.</u>
* 가변적 우선순위는 다음 식에 따라 계산한다.  
* $$
  \frac{서비스를 받을 시간+대기한 시간}{서비스를 받을 시간}
  $$

#### 다단계 큐 (Multilevel Queue Scheduling)
* **우선순위 스케줄링과 라운드 로빈이 결합한 스케줄링 알고리즘**
* 각 작업을 서로 다른 묶음으로 분류할 수 있을때 사용
* 따라서 작업을 다른 큐로 옮기지 않는다.

예를 들어,  
foreground / background task로 분류한다면 두 유형의 요청 반응시간은 다르므로 서로 다르게 스케줄링해야 한다.  
게다가 foreground는 background에 비해 우선순위가 높을 때가 많다.
foreground는 라운드 로빈으로, background는 선입선처리 스케줄링할 수 있다.  

또, **큐 사이에도 스케줄링해야 하는데 이는 고정된 선점 우선순위 스케줄링**이다.  

<u>우선순위가 높은 큐가 모두 비어 있기 전에는 낮은 우선순위 큐에 있는 프로세스를 실행할 수 없다.</u>  
또한 선점형이므로 <u>우선순위가 높은 큐에 작업이 들어오면 낮은 우선순위 큐에있는 프로세스는 할당된 CPU를 반납</u>해야한다.  

#### 다단계 피드백 큐(Multilevel Feedback Queue Scheduling)
* **다단계 큐 스케줄링에서 작업이 큐 사이를 이동할 수 있다는 점이 추가되었다.**
* 이때는 프로세서의 burst 특성에 따라 분리한다.
* 예를 들어 어떤 작업의 실행 시간이 너무 길면 작업을 낮은 단계 큐로 옮긴다.


~ 나머지 계속 정리

## Reference
<https://honbabzone.com/java/java-thread/>